"""
Agent state schema for the PM Agent LangGraph workflow.

This defines the shared state that flows through all nodes in the graph.
Uses Pydantic for validation and TypedDict-compatible annotations for LangGraph.
"""

from __future__ import annotations

import operator
from datetime import datetime, timezone
from typing import Annotated, Any, Dict, List, Literal, Optional

from langchain_core.messages import BaseMessage
from langgraph.graph import add_messages
from pydantic import BaseModel, Field


# ── Data models for each integration ──────────────────────────────

class SlackMessageData(BaseModel):
    """Represents a Slack message extracted from a channel."""
    message_id: str = ""
    channel_id: str = ""
    channel_name: str = ""
    user_id: str = ""
    user_name: str = ""
    timestamp: str = ""
    text: str = ""
    thread_ts: Optional[str] = None
    reactions: List[str] = Field(default_factory=list)
    is_thread_reply: bool = False


class JiraIssueData(BaseModel):
    """Represents a Jira issue."""
    issue_key: str = ""
    project_key: str = ""
    summary: str = ""
    description: str = ""
    issue_type: str = ""
    status: str = ""
    priority: str = ""
    labels: List[str] = Field(default_factory=list)
    reporter: str = ""
    assignee: Optional[str] = None
    created: str = ""
    updated: str = ""
    comments: List[Dict[str, str]] = Field(default_factory=list)


class GitHubItemData(BaseModel):
    """Represents a GitHub issue or PR."""
    item_type: Literal["issue", "pull_request"] = "issue"
    number: int = 0
    repository: str = ""
    title: str = ""
    body: str = ""
    state: str = ""
    labels: List[str] = Field(default_factory=list)
    author: str = ""
    created: str = ""
    updated: str = ""
    comments_count: int = 0
    # PR-specific
    changed_files: List[str] = Field(default_factory=list)
    additions: int = 0
    deletions: int = 0
    merged: bool = False


class NotionPageData(BaseModel):
    """Represents a Notion page or database entry."""
    page_id: str = ""
    title: str = ""
    url: str = ""
    last_edited: str = ""
    properties: Dict[str, Any] = Field(default_factory=dict)
    content_summary: str = ""


class WebContentData(BaseModel):
    """Represents web-sourced content (search results, Reddit, etc.)."""
    source: str = ""  # tavily, reddit, competitor_site
    url: str = ""
    title: str = ""
    content: str = ""
    published: str = ""
    category: str = ""  # pricing, feature, review, discussion
    sentiment: Optional[str] = None  # positive, negative, neutral


class InsightData(BaseModel):
    """An insight generated by analysis."""
    category: str = ""  # customer_sentiment, feature_request, technical_issue, market_trend, competitor_threat, internal_blocker
    title: str = ""
    description: str = ""
    severity: Literal["low", "medium", "high", "critical"] = "medium"
    source_agents: List[str] = Field(default_factory=list)
    evidence: List[str] = Field(default_factory=list)
    recommended_actions: List[str] = Field(default_factory=list)


class ActionItem(BaseModel):
    """An action to be taken (auto or manual)."""
    action_type: str = ""  # create_jira, post_slack, update_notion, alert
    description: str = ""
    priority: Literal["low", "medium", "high", "critical"] = "medium"
    auto_execute: bool = False
    target: str = ""  # channel, project key, page id
    payload: Dict[str, Any] = Field(default_factory=dict)
    status: Literal["pending", "approved", "rejected", "executed", "failed"] = "pending"


class AlertData(BaseModel):
    """An alert to be sent."""
    severity: Literal["low", "medium", "high", "critical"] = "medium"
    title: str = ""
    message: str = ""
    source: str = ""
    channel: str = ""


# ── Main Agent State ──────────────────────────────────────────────

def _merge_dicts(left: Dict[str, Any], right: Dict[str, Any]) -> Dict[str, Any]:
    """Merge two dicts, with right overriding left."""
    merged = {**left}
    merged.update(right)
    return merged


class AgentState(BaseModel):
    """
    The primary state object that flows through the LangGraph StateGraph.

    Uses Annotated reducers so that LangGraph correctly merges partial
    state updates returned by each node.
    """

    # ── Conversation / LLM messages ──
    messages: Annotated[List[BaseMessage], add_messages] = Field(default_factory=list)

    # ── Input context ──
    user_query: Optional[str] = None
    trigger_type: Literal["manual", "scheduled", "webhook", "slack_command"] = "manual"
    thread_id: str = ""

    # ── Supervisor routing ──
    current_agent: Optional[str] = None
    next_step: Optional[Literal[
        "supervisor", "slack_agent", "jira_agent", "github_agent",
        "market_research_agent", "notion_agent", "END"
    ]] = None

    # ── Collected data from integrations ──
    slack_data: List[SlackMessageData] = Field(default_factory=list)
    jira_data: List[JiraIssueData] = Field(default_factory=list)
    github_data: List[GitHubItemData] = Field(default_factory=list)
    notion_data: List[NotionPageData] = Field(default_factory=list)
    web_data: List[WebContentData] = Field(default_factory=list)

    # ── Analysis results ──
    results: Annotated[Dict[str, Any], _merge_dicts] = Field(default_factory=dict)
    insights: List[InsightData] = Field(default_factory=list)
    action_items: List[ActionItem] = Field(default_factory=list)
    alerts: List[AlertData] = Field(default_factory=list)

    # ── HITL ──
    human_approval: Optional[bool] = None
    pending_approval_context: Optional[str] = None

    # ── Output ──
    final_output: Optional[str] = None

    # ── Metadata ──
    metadata: Dict[str, Any] = Field(default_factory=dict)
    errors: List[str] = Field(default_factory=list)
    timestamp: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

    model_config = {"arbitrary_types_allowed": True}
